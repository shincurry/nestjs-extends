"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[958],{3905:(e,t,o)=>{o.d(t,{Zo:()=>d,kt:()=>h});var n=o(7294);function a(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function r(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function l(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?r(Object(o),!0).forEach((function(t){a(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function i(e,t){if(null==e)return{};var o,n,a=function(e,t){if(null==e)return{};var o,n,a={},r=Object.keys(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||(a[o]=e[o]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(a[o]=e[o])}return a}var s=n.createContext({}),p=function(e){var t=n.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):l(l({},t),e)),o},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var o=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=p(o),m=a,h=u["".concat(s,".").concat(m)]||u[m]||c[m]||r;return o?n.createElement(h,l(l({ref:t},d),{},{components:o})):n.createElement(h,l({ref:t},d))}));function h(e,t){var o=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=o.length,l=new Array(r);l[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[u]="string"==typeof e?e:a,l[1]=i;for(var p=2;p<r;p++)l[p]=o[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,o)}m.displayName="MDXCreateElement"},1799:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>p});var n=o(7462),a=(o(7294),o(3905));const r={sidebar_position:2},l="Module",i={unversionedId:"module",id:"module",title:"Module",description:"The Module in Nest.js is the most difficult and inconvenient part of the framework, but it is also the core part. There is no way to replace this part, so we have to make some tools to help us use it more easily.",source:"@site/docs/2.module.md",sourceDirName:".",slug:"/module",permalink:"/nestjs-extends/docs/module",draft:!1,editUrl:"https://github.com/shincurry/nestjs-extends/tree/main/website/docs/docs/2.module.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/nestjs-extends/docs/introduction"},next:{title:"Validation",permalink:"/nestjs-extends/docs/validation"}},s={},p=[{value:"Auto Dependency Injection (AutoDI)",id:"auto-dependency-injection-autodi",level:2},{value:"Auto load controllers",id:"auto-load-controllers",level:3},{value:"Auto load providers",id:"auto-load-providers",level:3},{value:"Auto load Sequelize models",id:"auto-load-sequelize-models",level:3},{value:"AutoDI path patterns",id:"autodi-path-patterns",level:3},{value:"Decorator Composition",id:"decorator-composition",level:3}],d={toc:p},u="wrapper";function c(e){let{components:t,...o}=e;return(0,a.kt)(u,(0,n.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"module"},"Module"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Module")," in Nest.js is the most difficult and inconvenient part of the framework, but it is also the core part. There is no way to replace this part, so we have to make some tools to help us use it more easily."),(0,a.kt)("h2",{id:"auto-dependency-injection-autodi"},"Auto Dependency Injection (AutoDI)"),(0,a.kt)("p",null,"Nest.js Extends Toolkit provides a set of decorators for loading controllers, providers and Sequelize models automatically:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"export type AutoControllerOptions = {\n  path: string[];\n};\n@AutoController(options: AutoControllerOptions);\n\nexport type AutoProviderOptions = {\n  path: string[];\n  export?: boolean;\n};\n@AutoProvider(options: AutoProviderOptions);\n\nexport type AutoSequelizeModelOptions = {\n  connection?: string;\n  path: string[];\n};\n@AutoSequelizeModel(options: AutoSequelizeModelOptions);\n")),(0,a.kt)("h3",{id:"auto-load-controllers"},"Auto load controllers"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"AutoController")," is the simplest decorator, it loads classes from the specified path and adds it to the ",(0,a.kt)("inlineCode",{parentName:"p"},"Module.controllers")," metadata array."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'@AutoController({\n  path: [\n    path.join("./controllers/**/*.js")\n  ]\n})\n@Module({})\nexport class DemoModule {}\n')),(0,a.kt)("h3",{id:"auto-load-providers"},"Auto load providers"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"AutoProvider")," is similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"AutoController"),", except that the loaded classes are added to ",(0,a.kt)("inlineCode",{parentName:"p"},"Module.providers"),". Also, there is an additional option ",(0,a.kt)("inlineCode",{parentName:"p"},"export?: boolean"),", if ",(0,a.kt)("inlineCode",{parentName:"p"},"export")," is ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"AutoProvider")," will also add the auto-loaded classes to the ",(0,a.kt)("inlineCode",{parentName:"p"},"Module.exports")," metadata array. If you want to make the module global, you should set ",(0,a.kt)("inlineCode",{parentName:"p"},"export")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'@AutoProvider({\n  path: [\n    path.join("./services/**/*.js")\n  ],\n  export: true,\n})\n@Global()\n@Module({})\nexport class DemoModule {}\n')),(0,a.kt)("h3",{id:"auto-load-sequelize-models"},"Auto load Sequelize models"),(0,a.kt)("p",null,"To begin using it, we first install the required dependencies."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npm install --save @nestjs/sequelize sequelize sequelize-typescript\nnpm install --save-dev @types/sequelize\n")),(0,a.kt)("p",null,"The implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"AutoSequelizeModel")," differs from the first two decorators in that it does not add classes to the module metadata, but uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"SequelizeModule.forFeature")," method to store auto-loaded models. there is an additional option ",(0,a.kt)("inlineCode",{parentName:"p"},"connection?: string")," with a default value of ",(0,a.kt)("inlineCode",{parentName:"p"},"DEFAULT_CONNECTION_NAME"),", note that this value needs to be the same as the ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," value set in the ",(0,a.kt)("inlineCode",{parentName:"p"},"SequelizeModule.forRoot"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'const ROOT_CONNECTION_NAME = "root_connection"\n\n@AutoSequelizeModel({\n  connection: ROOT_CONNECTION_NAME,\n  path: [\n    path.join(__dirname, "./feature1/models/**/*.js"),\n  ],\n})\n@Module({})\nexport class Feature1Module {}\n\n@AutoSequelizeModel({\n  connection: ROOT_CONNECTION_NAME,\n  path: [\n    path.join(__dirname, "./feature2/models/**/*.js"),\n  ],\n})\n@Module({})\nexport class Feature2Module {}\n\n@Module({\n  imports: [\n    SequelizeModule.forRoot({\n      name: ROOT_CONNECTION_NAME,\n      dialect: \'postgres\',\n    }),\n    Feature1Module,\n    Feature2Module,\n  ],\n})\nexport class RootModule {}\n\n')),(0,a.kt)("h3",{id:"autodi-path-patterns"},"AutoDI path patterns"),(0,a.kt)("p",null,"Pay attention to the extension of source file in path patterns. You should pass in the path to the compiled .js file instead of the path to the .ts source code."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'@AutoController({\n  path: [\n    path.join("./controllers/**/*.ts") // \u274c\n  ]\n})\n@Module({})\nexport class DemoModule {}\n\n@AutoController({\n  path: [\n    path.join("./controllers/**/*.js") // \u2705\n  ]\n})\n@Module({})\nexport class DemoModule {}\n')),(0,a.kt)("h3",{id:"decorator-composition"},"Decorator Composition"),(0,a.kt)("p",null,"According to Typescript's documentation on decorators ",(0,a.kt)("sup",{parentName:"p",id:"fnref-1"},(0,a.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),":"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"The following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:"),(0,a.kt)("ol",{parentName:"blockquote"},(0,a.kt)("li",{parentName:"ol"},"The expressions for each decorator are evaluated top-to-bottom."),(0,a.kt)("li",{parentName:"ol"},"The results are then called as functions from bottom-to-top."))),(0,a.kt)("p",null,"Until now (Nest.js v9.3.9), the implementation of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Module")," decorator does not support inheritance from the existing ",(0,a.kt)("inlineCode",{parentName:"p"},"ModuleMetadata")," data, so if you add AutoDI decorators between ",(0,a.kt)("inlineCode",{parentName:"p"},"@Module")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"class"),", these will not have any effect."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// \u274c\n@Module({})\n@AutoProvider({ /** */ })\nclass DemoModule {}\n\n// \u2705\n@AutoProvider({ /** */ })\n@Module({})\nclass DemoModule {}\n")),(0,a.kt)("div",{className:"footnotes"},(0,a.kt)("hr",{parentName:"div"}),(0,a.kt)("ol",{parentName:"div"},(0,a.kt)("li",{parentName:"ol",id:"fn-1"},(0,a.kt)("a",{parentName:"li",href:"https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-composition"},"TypeScript: Documentation - Decorators (typescriptlang.org)"),(0,a.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")))))}c.isMDXComponent=!0}}]);